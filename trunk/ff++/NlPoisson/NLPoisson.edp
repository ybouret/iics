load "iovtk"
verbosity=0;
int n=10;
int aNx=n;
int aNy=n;
int Nc=10*n;
int circle=10;
int cycle=0;
real Lx=12.0,Ly=12.0;
real kT=10;
real sigma=0.0;
real dPs=1.0;
real T=10000, dt=1,t;

real a=1;
real b=2;
int i;
//domain definition boundaries
border C11(t=0,Lx){x=t;y=-Ly/2+0*sin(t*2*pi/Lx); label=1;}
border C12(t=0,Ly){x=Lx;y=-Ly/2+t; label=2;}
border C13(t=0,Lx){x=Lx-t;y=+Ly/2; label=3;}
border C14(t=0,Ly){x=0;y=+Ly/2-t; label=4;}


border hole0(t=0,2*pi){x=Lx*0.5+a*cos(t);y=b*sin(t);label=circle;};
mesh 	Th=buildmesh(C11(aNx)+C12(aNy)+C13(aNx)+C14(aNy)+hole0(-Nc));

//fespace VVh(Th,[P2,P2,P2]);
fespace Vh(Th,P2);
macro Grad(u)[dx(u),dy(u)]//
macro div(u1,u2) (dx(u1)+dy(u2))//
real Volume;
Vh p,q,K;
Vh vx,vy,dP;
//________________________________________________________________________
//  Function for  the computation of the Curvature of the bubble 						
//________________________________________________________________________
func real computeCurvature()
{
	verbosity=0;
	
	//real epsilon=1e-10;
	
	Vh sp1,Nx,Ny; //variable d'integration
	solve giveNx(Nx,sp1)=
						int2d(Th)(dx(Nx)*dx(sp1)+dy(Nx)*dy(sp1))
						+int1d(Th,circle)(Nx*sp1)
						-int1d(Th,circle)(N.x*sp1);  
						
    solve giveNy(Ny,sp1)=int2d(Th)(dx(Ny)*dx(sp1)+dy(Ny)*dy(sp1))
    					+int1d(Th,circle)(Ny*sp1)
    					-int1d(Th,circle)(N.y*sp1);
        
    solve giveCurvature(K,sp1)= 
    					 int2d(Th)((dx(K)*dx(sp1)+dy(K)*dy(sp1))*pow(Nx*Nx+Ny*Ny,1.5))    
    					+int1d(Th,circle)(K*sp1*pow(Nx*Nx+Ny*Ny,1.5))
    					-int1d(Th,circle)
    					(
    					(
    						(Ny*Nx*dx(Ny)-Ny*Ny*dx(Nx)-Nx*Nx*dy(Ny)+Nx*Ny*dy(Nx))
    						*sp1
    					)
    					);
    					
    					
     return 0;
}
//____________________________________________________________________________________
//	Function for determining the rheology
//____________________________________________________________________________________
macro f(p ) giveF(Grad(p )'*Grad(p ))//
macro df(p ) givedF(Grad(p )'*Grad(p ))//
func real giveF(real adP)
{
	if(adP<1)
			return 1e-2*sqrt(adP);
		else
		{
			real idP=1.0/sqrt(adP);
			
			return (1.0+4.5*idP-5.5*idP*idP*idP);
		}
}

func real givedF(real adP)
{
	if(adP<1.0)
		return 1e-2;
	else
	{
		real idP2=1.0/(adP);
		return (-4.5*idP2+16.5*idP2*idP2);
	}
}

//____________________________________________________________________________________
//	Function for solving the NL poisson equation for pressure
//____________________________________________________________________________________
problem stokesInitial(p,q)=
		int2d(Th)((Grad(p )'*Grad(q)))
		+on(4,p=-1)
		+on(circle,p=kT/Volume-sigma*K);
		
	
Vh dp;
Vh vxv,vyv;

func real computePressureAndVelocity()
{
	real error=1;
	int i;
	verbosity=0;
	
	//Computation of the bubble volume
	Volume=Lx*Ly-int2d(Th)(1.0);

	computeCurvature();
	stokesInitial;

	problem NL(dp,q)=
			 int2d(Th)( (Grad(dp )'*Grad(q))*f(p ) ) 
			+int2d(Th)( (Grad( p )'*Grad(q))*f(p ) )
			+int2d(Th)( (Grad( p )'*Grad(q))*df(p )*(Grad(dp)'*Grad(p ) ))	
			+on(1,2,3,circle,dp=0);
						
	while(error>1e-3)
	{
		NL;
		error=sqrt(int2d(Th)(dp^2));
		p=p+dp;
			cout<< "error is "<< error<< "iterations"<<endl;
		plot(p );
		i++;
		if(i>100)
		{
			cout <<"Convergence problem in solving pressure"<<endl;
			break;
		}
	}
	cout<< "Converged in "<< i<< "iterations"<<endl;
	dP=f(p);
	Vh af;
	{	
		solve giveVelocityX(vx,vxv)=
				int2d(Th)(dx(vx)*dx(vxv)+dy(vx)*dy(vxv))
				+on(1,2,3,4,vx=0)
				+int1d(Th,circle)(vxv*(vx))
				+int1d(Th,circle)(vxv*dx(p )*f(p ));
				
		solve giveVelocityY(vy,vyv)=
				int2d(Th)(dx(vy)*dx(vyv)+dy(vy)*dy(vyv))
				+on(1,2,3,4,vy=0)
				+int1d(Th,circle)(vyv*(vy))
				+int1d(Th,circle)(vyv*dy(p )*f(p ));
	}
	return error;
}
//first test for mesh adaptation		
Volume=Lx*Ly-int2d(Th)(1.0);

plot(Th);
//Th=adaptmesh(Th,p,err=0.01);

computePressureAndVelocity();		


Th=adaptmesh(Th,p,err=0.01);
exec("rm ./data/*");
for(real t=0;t<T;t+=dt)
{
	//Th=adaptmesh(Th,K,err=0.01);

	computeCurvature();
	computePressureAndVelocity();		
	Th=movemesh(Th,[x+dt*vx,y+dt*vy]);
	savevtk("./data/U"+cycle+".vtu",Th,[vx,vy,0],p,K,dp,dP,f(dP),[dx(p ), dy(p ), 0],dataname="V P K ErrorP dP F GradP");
	cycle++;
}


