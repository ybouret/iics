load "iovtk"
verbosity=0;
int  n=20;
int  aNx=n;
int  aNy=n;
int  Nc=10*n;
int  circle=10;
int  cycle=0;
real Lx=12.0,Ly=12.0;
real kT=10;
real sigma=0.0;
real dPs=1.0;
real T=10000, dt=1,t;

real a=2;
real b=3;
int i;

func real blob_radius()
{
	
	return 0;	
}

//domain definition boundaries
border C11(t=0,Lx){x=t;    y=-Ly/2+0*sin(t*2*pi/Lx); label=1;}
border C12(t=0,Ly){x=Lx;   y=-Ly/2+t;  label=2;}
border C13(t=0,Lx){x=Lx-t; y=+Ly/2;    label=3;}
border C14(t=0,Ly){x=0;    y=+Ly/2-t;  label=4;}

int Right = 2;


border hole0(t=0,2*pi){x=Lx*0.5+a*cos(t);y=b*sin(t);label=circle;};

mesh 	Th=buildmesh(C11(aNx)+C12(aNy)+C13(aNx)+C14(aNy)+hole0(-Nc));

fespace Vh(Th,P2);
macro Grad(u)[dx(u),dy(u)]//
macro div(u1,u2) (dx(u1)+dy(u2))//
real Volume;

Vh p,q,K;
Vh vx,vy,dP;
Vh Nx,Ny;
Vh phi;

//______________________________________________________________________________
//  Function for  the computation of the Curvature of the bubble 						
//______________________________________________________________________________
func real computeCurvatureOld()
{
	verbosity=0;
	//--------------------------------------------------------------------------
	//
	// Compute the topology field phi
	//
	//--------------------------------------------------------------------------

	solve givephi(phi,q) =
			int2d(Th)((dx(phi)*dx(q)+dy(phi)*dy(q)) )
			+on(circle,phi=1)
			+on(1,2,3,4,phi=0);
			
	//--------------------------------------------------------------------------
	//
	// Deduce the normal to the curves: - Grad(phi)/|Grad(phi)|
	//
	//--------------------------------------------------------------------------
	Nx=-dx(phi)/sqrt(dx(phi)^2+dy(phi)^2);
	Ny=-dy(phi)/sqrt(dx(phi)^2+dy(phi)^2);
	
	//--------------------------------------------------------------------------
	//
	// compute the curvature
	//
	//--------------------------------------------------------------------------
    real small=1e-10;
    solve giveCurvature(K,q) =
    	//int2d(Th)((dx(K)*dx(q)+dy(K)*dy(q)))
    	int2d(Th)(small*K*q)
		+int1d(Th,circle)(K*q)
		-int1d(Th,circle)
			(
				-((Ny*Nx*dx(Ny)-Ny*Ny*dx(Nx)-Nx*Nx*dy(Ny)+Nx*Ny*dy(Nx))*q)
				//(dx(Nx)+dy(Ny))*q
			);
			
     return 0;
}

//______________________________________________________________________________
//  Function for  the computation of the Curvature of the bubble
//______________________________________________________________________________
func real computeCurvature()
{
        verbosity=0;

        //real epsilon=1e-10;
        //--------------------------------------------------------------------------
        //
        // N: defined by FreeFem as the normal vector to the interfaces
        // Nx : scalar product N \cdot x
        //--------------------------------------------------------------------------
        Vh sp1; //variable d'integration
        Vh spx,spy;
        real small=1e-2;
        // \Delta Nx = 0 and Nx=N.x on the bubbles

        /*
        solve givephi(phi,spx)=
                                                int2d(Th)((dx(phi)*dx(spx)+dy(phi)*dy(spx)) )
                                                +on(circle,phi=1)
                                                +on(1,2,3,4,phi=0);
        Nx=dx(phi)/sqrt(dx(phi)^2+dy(phi)^2);
        Ny=dy(phi)/sqrt(dx(phi)^2+dy(phi)^2);
        */



        solve giveNx(Nx,spx)=int2d(Th)(Nx*small*spx)+int1d(Th,circle)(Nx*spx)-int1d(Th,circle)(N.x*spx);
        solve giveNy(Ny,spy)=int2d(Th)(Ny*small*spy)+int1d(Th,circle)(Ny*spy)-int1d(Th,circle)(N.y*spy);


        //solve giveNx(Nx,sp1)=int2d(Th)(dx(Nx)*dx(sp1)+dy(Nx)*dy(sp1))+int1d(Th,circle)(Nx*sp1)-int1d(Th,circle)(N.x*sp1);
        //solve giveNy(Ny,sp1)=int2d(Th)(dx(Ny)*dx(sp1)+dy(Ny)*dy(sp1))+int1d(Th,circle)(Ny*sp1)-int1d(Th,circle)(N.y*sp1);


    solve giveCurvature(K,sp1)=
                                //       int2d(Th)(small*K*sp1)
                                //      int2d(Th)(small*K*sp1)
                                        int2d(Th)(small*Grad(K)'*Grad(sp1))
                                        +int1d(Th,circle)(K*sp1)
                                        -int1d(Th,circle)
                                        (
                                                (Ny*Nx*dx(Ny)-Ny*Ny*dx(Nx)-Nx*Nx*dy(Ny)+Nx*Ny*dy(Nx))
                                                *sp1
                                        );
     return 0;
}

//______________________________________________________________________________
//	Function for determining the rheology
//______________________________________________________________________________
macro f(p )  giveF( sqrt(Grad(p )'*Grad(p )) )  //
macro df(p ) givedF(sqrt(Grad(p )'*Grad(p )) ) //

func real giveF(real adP)
{
	return 1;
	
	if(adP<1)
			return 1e-2; //*sqrt(adP);
	else
	{
			real idP=1.0/(adP);
			
			return (1.0+4.5*idP-5.5*idP*idP*idP);
	}
}

func real givedF(real adP)
{
	return 0;
	
	if(adP<1.0)
		return 0; //1e-2;
	else
	{
		real idP2=1.0/(adP^2);
		return (-4.5*idP2+16.5*idP2*idP2);
	}
}

//______________________________________________________________________________
//	Function for solving the NL poisson equation for pressure
//______________________________________________________________________________
problem stokesInitial(p,q)=
		int2d(Th)((Grad(p )'*Grad(q)))
		+on(Right,p=1)
		+on(circle,p=kT/Volume-sigma*K);
		
	
Vh dp;
Vh vxv,vyv;

func real computePressureAndVelocity()
{
	real error=1;
	int i;
	verbosity=0;
	
	Volume=Lx*Ly-int2d(Th)(1.0);	// Computation of the bubble volume
	computeCurvature();             // curvature field
	stokesInitial;                  // Newtonian pressure with Laplace's pressure on bubble

	problem NL(dp,q)=
			 int2d(Th)( (Grad(dp )'*Grad(q))*f(p ) ) 
			+int2d(Th)( (Grad( p )'*Grad(q))*f(p ) )
			+int2d(Th)( (Grad( p )'*Grad(q))*df(p )*(Grad(dp)'*Grad(p ) ))	
			+on(1,2,3,4,circle,dp=0);
						
	while(error>1e-3)
	{
		NL;
		error=sqrt(int2d(Th)(dp^2));
		p=p+dp;
			cout<< "error is "<< error << endl;
		plot(p );
		i++;
		if(i>100)
		{
			cout <<"Convergence problem in solving pressure"<<endl;
			break;
		}
	}
	cout<< "Converged in "<< i<< " iterations"<<endl;
	dP=f(p);
	Vh af;
	{	
		solve giveVelocityX(vx,vxv)=
				int2d(Th)(dx(vx)*dx(vxv)+dy(vx)*dy(vxv))
				+on(1,2,3,4,vx=0)
				+int1d(Th,circle)(vxv*(vx))
				+int1d(Th,circle)(vxv*dx(p )*f(p ));
				
		solve giveVelocityY(vy,vyv)=
				int2d(Th)(dx(vy)*dx(vyv)+dy(vy)*dy(vyv))
				+on(1,2,3,4,vy=0)
				+int1d(Th,circle)(vyv*(vy))
				+int1d(Th,circle)(vyv*dy(p )*f(p ));
	}
	return error;
}

//first test for mesh adaptation		
Volume=Lx*Ly-int2d(Th)(1.0);

plot(Th);
//Th=adaptmesh(Th,p,err=0.01);

computePressureAndVelocity();		


//Th=adaptmesh(Th,p,err=0.01);
exec("rm -f ./data/*");
int[int] fforder=[1,1,1,1,1];

for(real t=0;t<T;t+=dt)
{
	//Th=adaptmesh(Th,K,err=0.01);

	computeCurvature();
	computePressureAndVelocity();		
	//Th=movemesh(Th,[x+dt*vx,y+dt*vy]);
	//savevtk("./data/U"+cycle+".vtk",Th,[vx,vy,0],p,K,dp,dP,f(dP),[dx(p ), dy(p ), 0],[Nx,Ny,0],dataname="V P K ErrorP dP F GradP N",order=fforder);
	savevtk("./data/U"+cycle+".vtk",Th,[Nx,Ny,0],p,K,Nx,Ny,phi,dataname="N P K Nx Ny phi",order=fforder);
	cycle++;
}


